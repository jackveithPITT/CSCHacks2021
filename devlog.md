# CSCHacks 2021 Devlog
I will attempt to detail all of (or at least the most major/headache-inducing/time-consuming) roadblocks in this document, so that I can track my progress and hopefully accurately detail the things that got in my way and what I had to learn to solve these issues.

# Project Creation through Oct 15, 2021

**note - as I am only starting this devlog a few weeks into the creation of the project, this section will be a bit of a dump from the top of my head. Essentially this project consists of two separate applications working together to provide the final service:**
- the Firefox extension itself, which will display the GUI, process input from the User, and send that data to the server
- a node.js server running Express that handles connections from all extension clients, and handles serving web resources to the Users, along with keeping track of their login sessions and the persistent data that accumulates as the extension is used, all being stored in a mySQL database

As I have already made a pretty simple Firefox extension previously (Search 'Youtime' on the extension market) I already knew about the basic construction of an extension, for example the 4 types of scripts for the different ways an extension can interact with the browser, the manifest.json, and so on. I have also made simple node servers and dabbled in Express, but making a full-fledged application is going to be a new experience for me, and presumably a worthy challenge.
### First Things First
the first thing that I wanted to get up and running was the mySQL connection to the Express server. I knew this would be essential so I wanted to get it integrated prior to things getting messy later down the line. I already had mySQL downloaded from previous ventures, and I followed a few guides online that would provide me with a simple template for storing user login data in a database. Data in mySQL is sorted into tables; I keep all login information such as emails, usernames, PIDs, and hashed passwords in a single table. I know that later down the line I will inevitably have to actually create new tables, most likely for each PID/User in order to store the persistent information related to their account.

I then set up some more simple paths in the server, as the connection to the mySQL database is technically a single line of code, two if you count the 'require'. A simple login page, and a POST request that logs a User in if their username and password exist in the database (nothing cryptographically secure yet, that will come later). I also implemented some express middleware, which essentially allow me to perform certain functions on request and response objects in order to process HTTP calls in an efficient manner, and exactly how I would like to. For now I am using the built in static middleware to server static files like CSS documents for HTML pages, a body parser to obtain JSON data from request objects, and express sessions which I will be working with more extensively in the future. As there was not much more I could do with the server at the time, I began work on the Extension.

unmentioned issues/learning:
- learning the mySQL Workbench interface
- mySQL server as a Windows service
- HTTP requests and their differing types/usage
- express routing

### First Connections
I wanted to get a connection started between the Extension in the browser and the Server I was hosting on computer using localhost. This is where a lot of issues begin. First I needed to select a way to send these requests to the server. My initial idea was to use XMLHTTPRequests in order to get resources from the server to update the GUI of the extension. However I found out about websockets shortly after, which offer a way to create a persistent connection between a client and server, allowing a request or data transfer to be initiated by either the client or the server. Websockets are natively supported by nearly all modern browsers, so it seemed like a great choice. I worked on implementing these in my extension, but I found that no matter what I did I was unable to get them to work! I set the idea aside for a bit and tried to implement the fetch command, which is much simpler than establishing a websocket connection and is essentially a more supported and flexible XHR request. But I was unable to get this to work either!
<hr>

 This so far has by far been my largest roadblock. I learned many things trying to fix this issue, such as HTTP headers, Content Security Policy permissions, Cross Origin Resource Sharing, etc. However I was unable to find anything about this issue online, so I had to figure it out myself. The entire time I had all of my server requesting code in my **Browser Action Script**, a script that runs when the little extension icon in the upper right corner of the browser chrome is clicked. I had it this way as I thought it would be best to establish a connection when the User wanted to use the extension, and not have a connection persistently online. HOWEVER, on a whim I decided to try moving this code into the **Background Script**, which is run once when the extension is loaded. And the fetch request went through! my `console.log()` calls on both ends (client and server) both displayed their respective payloads, and all of the meaningful routines of the Extension completed with only a few (unrelated) errors. As far as I can tell, the Browser Action does not have the permissions to actually make requests to a server on its own, and thus must delineate such actions to the more privileged Background Script. Phew! Next time I will be implementing exactly what I just mentioned, because Extensions have a built in way to allow the different scripts to communicate with each other using `browser.runtime.connect()`.

 # Oct 16, 2021
 ### SSL Signing
 today began with me attempting to figure out why I was getting errors when trying to push my project to the main branch of my github repo. Learned a few things about fetching, pulling etc. and was able to fix my non-fast-forward issue. This is the first project where I am extensively using git from the command line (or at all for that matter) so its nice to be able to understand more about this useful version control system. Now that I'm able to establish a websocket connection in the first place, I'm going to make sure that its secure using Secure Sockets Layer (SSL) by generating a self-signed certificate using openSSL's tools. This lets me run my entire server over HTTPS, which is more secure than HTTP. I ran into some issues getting this to work, but it turned out to be a silly mistake where I didn't actually tell the server what the certificate passphrase was. Now I can securely transfer data with my fetch requests and websockets.

 ### Script Communication
 I was also able to use the messaging API provided by Firefox extensions in order to establish a connection between my BAS (Browser Action Script) and BS (Background Script). I might inevitably need to do this again in the future between the CS (Content Script), the script which is run on the individual tabs and pages loaded in the browser, and the BS. I might need it to be able to process information about the tabs ( specifically the URL) in order to determine URL uniqueness. However the BS might be able to do this on its own; this is a problem for a later date. Now that the BAS and the BS are hooked up, I will be able to use events from the Browser Action's HTML page to query resources from the server. For now I was only able to do some dummy `fetch()` calls to make sure that the client and server responded correctly; my plan for the future is to use a fetch request to log in the User, then establish a secure websocket connection to the server for a more privileged User.
